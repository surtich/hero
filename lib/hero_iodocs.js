var   fs   = require('fs'),
path       = require('path'),
clone      = require('clone'),
beautify   = require('js-beautify').js_beautify;

const ERROR = {
 noError: {
  "code": 0, 
  "msg": ""
 },
 empty: {
  "code": 1, 
  "msg": "The parameter is empty"
 },
 noExists: {
  "code": 2, 
  "msg": "The path no exists"
 },
 exists: {
  "code": 3, 
  "msg": "The path already exists"
 },
 system : {
  "code": 999, 
  "msg": "System error"
 }
}

function HeroIODocs(basedir, iodocsSubdir, apisConfig) {

 var self = this;
 self.basedir = basedir;
 self.iodocsSubdir = iodocsSubdir;
 self.apisConfig = apisConfig;

 var skels = require(path.join(self.basedir, self.iodocsSubdir , 'public/data/skels.json'));

 self.skelProject = skels.skelProject;
  
 self.dirPaths = skels.dirPaths;
 self.skelApi = skels.skelApi;
  
  
 var result = createDirectories();
 if (result === ERROR.noError) {
  createIrisResources(skels.iris);
 } else {
  console.log("HERO-I/O Docs result:", result);
 }

 function createDirectories() {
  var e = ERROR.noError;
  try {
   self.apis = {};
   for (var apiName in self.apisConfig) {
    self.skelProject.src[apiName] = clone(self.skelApi);
    self.apis[apiName] = require(path.join(self.basedir, self.iodocsSubdir , 'public/data/') + apiName + '.json');
    createServerPaths(self.apis[apiName], self.skelProject.src[apiName], apiName);
   }
   e = createSkel(self.basedir, self.skelProject);
   return e;
  } catch (err) {
   e = ERROR.system;
   e.err = err;
   return e;
  }
 }
 
 function generateIrisResourceMethodName(method, endPointName) {  
  var name = method.HTTPMethod.toLowerCase();
  var uri = method.URI.replace(new RegExp(":" + endPointName + "([^/]*)"), "by$1", "gi");
  uri = uri.replace(/:[^/]*/g, "").replace(/\?*./, "");
  var tokens = uri.split("/");
  for (var i = 0; i < tokens.length; i++) {
   var token = tokens[i];
   if (token != endPointName) {
    name += token.substr(0, 1).toUpperCase() + token.substr(1);
   }
  }
  return name;
 }
 
 function createIrisResources(irisPaths) {
  for (var apiName in self.apis) {
   var apiDefinition = self.apis[apiName];
   var init = path.join(self.basedir, "src", apiName, irisPaths.baseURI, irisPaths.initPath);    
   for (var i = 0; i < apiDefinition.endpoints.length; i++) {
    var endpoint = apiDefinition.endpoints[i];
    var file =  path.join(self.basedir, "src", apiName, irisPaths.baseURI, irisPaths.resourcePaths, "_" + endpoint.name.toLowerCase() + ".js");    
    var contents =  "/**___ DO NOT MODIFY. AUTOMATICALLY GENERATED BY HERO-I/O DOCS.*/\n\n";
    contents += "iris.resource(\n\tfunction(self){"
    for (var j = 0; j < endpoint.methods.length; j++) {
     var method = endpoint.methods[j];
     if (!method.hero.iris || method.hero.iris.generate !== false) {
      var name = !method.hero.iris || !method.hero.iris.method ? generateIrisResourceMethodName(method, endpoint.name.toLowerCase()) : method.hero.iris.method ;
      var params = [];
      var uri = method.URI;
      var bodyParams = "";
      var queryParams = ""
      var endWithParam = uri.search(/\/:[^/]*$/) !== -1;
      for (var k = 0; k < method.parameters.length; k++) {
       var param = method.parameters[k];
       switch (param.Location) {
        case "pathReplace":
         params.push("p_" + param.Name);
         uri = uri.replace(new RegExp("/:" + param.Name + "(/*.)"), "/\" + " + "p_" + param.Name + " + \"$1");
         uri = uri.replace(new RegExp("/:" + param.Name + "$"), "/\" + " + "p_" + param.Name);
         break;
        case "body":
         params.push("p_" + param.Name);
         if (method.HTTPMethod.search(/post|put/i) != -1) {
          if (bodyParams) {
           bodyParams += ", ";
          }
          bodyParams += param.Name + ": " + "p_" + param.Name;
         }
         break;
        case "query":
         params.push("p_" + param.Name);
         if (method.HTTPMethod.search(/get|delete/i) != -1) {
          endWithParam = true;
          if (queryParams) {
           queryParams += "+ \"&";
          }
          queryParams += param.Name + "=\" + " + "p_" + param.Name;
         }
         break;
       }
      }
      params.push("f_ok");
      params.push("f_error");
      contents += "\n\n\t\tself." + name + " = function(" + params.join(",").replace(/,/g, ", ") + ") {";
      contents += "\n\t\t\treturn self.";
      if (method.HTTPMethod.search(/delete/i) != -1) {
       contents += "del";
      } else {
       contents += method.HTTPMethod.toLowerCase();
      }
      contents +=  "(\"" + uri;
      if (!endWithParam) {
       contents += "\"";
      }
      if (queryParams) {
       contents += "?" + queryParams;
      }
      if (method.HTTPMethod.search(/post|put/i) != -1) {
       contents += ", {" + bodyParams + "}";
      }
      contents += ", f_ok, f_error);";
      contents += "\n\t\t};";
     }
    }
    contents += "\n\n\t},";
    contents += "\niris.path.resource." + endpoint.name.substr(0, 1).toLowerCase() + endpoint.name.substr(1) + ");";
    console.log(path.join(irisPaths.resourcePaths, endpoint.name.toLowerCase() + ".js")); 
   createFile(file, true, contents);
   }
  
  }
 }


 function createServerPaths(apiDefinition, skelApp, apiName) {
  skelApp[apiName + ".js"] = "";
  
  for (var i = 0; i < apiDefinition.endpoints.length; i++) {
   var endpoint = apiDefinition.endpoints[i];
   var service = formatName(endpoint.name);
   //skelApp[ service + ".js"] = "";
   for (var j = 0; j < endpoint.methods.length; j++) {
    var method = endpoint.methods[j];
    if (method["hero"] && method["hero"]["handler"]) {
     if (Object.prototype.toString.call( method["hero"]["handler"] ) !== '[object Array]') {
      method["hero"]["handler"] = [method["hero"]["handler"]];
     }
     for (var k = 0; k < method["hero"]["handler"].length; k++) {
      var contents =  "/**___ DO NOT MODIFY. AUTOMATICALLY GENERATED BY HERO-I/O DOCS.\n";
      contents +=  "\n\tSynopsis\t: " + method["Synopsis"] ;
      contents +=  "\n\tMethod\t\t: " + method["HTTPMethod"];
      contents +=  "\n\tPath\t\t: " + method["URI"] + "\n";
      contents +=  "\n\tNum Params\t\t: " + method.parameters.length + "\n";
      for (var l = 0 ; l < method.parameters.length; l++) {
       var param = method.parameters[l];
       if (param.Location === "body") {
        contents +=  "\n\treq.body.";
       } else if (!param.Location || param.Location === "query") {
        contents +=  "\n\treq.query.";
       } else if (param.Location === "pathReplace") {
        contents +=  "\n\treq.params.";
       } else if (param.Location === "header") {
        contents +=  "\n\treq.headers.";
       }

       contents +=  param.Name + "\t\t\t: " + param["Description"];
       if (param["Default"]) {
        contents += " ( example: " + param["Default"] + " )";
       }
      }
      
      //contents += "\n}";
      //contents += "\n\nmodule.exports = handler;";
      contents += "\n\nEND OF AUTOMATICALLY GENERATED BY HERO-I/O DOCS.___*/";
      contents = beautify(contents , {
       "indent_size": 1, 
       "indent_with_tabs": false, 
       "preserve_newlines": true
      });
      
      
      skelApp[self.dirPaths][method["hero"]["handler"][k]] = {
       "type": "file",
       "overwrite": "replace",
       "contents": contents
      };
     }
    }
   }
  }
 }

 function createSkel(basePath, skel) {
  var e = ERROR.noError;

  for (var file in skel) {
   var pathFile = path.join(basePath, file);
   if (typeof skel[file] === "object" && skel[file].type !== "file") {
    e = createDir(pathFile);
    if (e !== ERROR.noError) {
     break;
    } else {
     e = createSkel(pathFile, skel[file]);
     if (e !== ERROR.noError) {
      break;
     }  
    }       
   } else {
    if (typeof skel[file] === "string") {
     createFile(pathFile, false, skel[file]);
    } else {
     createFile(pathFile, skel[file].overwrite, skel[file].contents);
    }    
   }      
  }
  return e;
 }

 function checkPath(path) {
  if (!path) {
   return ERROR.empty;
  } else {
   if (!fs.existsSync(path)) {
    return ERROR.noExists;
   } else {
    return ERROR.exists;
   }
  }
 }

 function createDir(path) {
  var e = checkPath(path);
  if (e === ERROR.empty) {
   return e;
  } else {
   if (!fs.existsSync(path)) {
    fs.mkdirSync(path);
   }
   return ERROR.noError;
  }
 }

 function createFile(path, overwrite, content) {
  var e = checkPath(path);
  if (e === ERROR.empty) {
   return e;
  } else {
   if (!fs.existsSync(path) || overwrite === true) {
    //fs.closeSync(fs.openSync(path, 'w'));
    fs.writeFileSync(path, content);
    return ERROR.noError;
   } else if (overwrite === "replace") {
    var oldContent = fs.readFileSync(path, 'utf8');
    var start = oldContent.indexOf(content.substr(0, 20));
    var end = oldContent.indexOf(content.substr(-20));
    if (start > -1 && end > -1) {
     end += 20;     
     var newContent = oldContent.substr(0, start) + content + oldContent.substr(end, oldContent.length) ;
     fs.writeFileSync(path, newContent);
    } else {
     fs.writeFileSync(path, content + "\n\n" + oldContent);
    }
    return ERROR.noError;
   } else {
    return ERROR.noError;
   }
  }
 }
 
 function readFile(path) {  
  if (!fs.existsSync(path)) {    
   return "";
  } else {
   return fs.readFileSync(path);
  }
 }
 
 
 function formatName(name) {
  return name.replace(" ", "_").toLowerCase();
 }
}

exports.HeroIODocs = HeroIODocs;
